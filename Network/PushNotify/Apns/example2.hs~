-- GSoC 2013 - Communicating with mobile devices.

{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleContexts, GADTs #-}

-- | This Module define the main function to send Push Notifications through Apple Push Notification Service.
--module Network.PushNotify.Apns.Send (sendAPNS) where
module Send (send) where
--import Network.PushNotify.Apns.Types
--import Network.PushNotify.Apns.Constants

import Types
import Constants
import Data.Serialize
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as LB
import Data.Text.Encoding           (encodeUtf8)
import Data.Text                    (unpack,pack)
import qualified Data.Aeson.Encode as AE
import Data.Time.Clock.POSIX
import Data.Time.Clock
import Data.Word
import Network.Connection
import Network.Socket.Internal      (PortNumber(PortNum))
import Data.Default
import Data.Convertible             (convert)

connParams :: ConnectionParams
connParams = ConnectionParams{
                connectionHostname = "localhost"
            ,   connectionPort     = fromInteger cDEVELOPMENT_PORT
            ,   connectionUseSecure = TLSSettings Params -- Nothing -- Just def
            ,   connectionUseSocks = Nothing
            }

-- | 'sendAPNS' sends the message through a APNS Server.
send :: APNSmessage -> IO ()
send msg = do
        ctime      <- getPOSIXTime
        cContext   <- initConnectionContext
        connection <- connectTo cContext connParams
        connectionPut connection $ runPut $ createPut msg{deviceToken = "7518b1c2c7686d3b5dcac823231"} ctime


createPut :: APNSmessage -> NominalDiffTime -> Put
createPut msg ctime = do
   let
       btoken     = encodeUtf8 $ deviceToken msg -- I have to check if encodeUtf8 is the appropiate function.
       bpayload   = AE.encode msg
       expiryTime = case expiry msg of
                      Nothing ->  round (ctime + posixDayLength) :: Word32 -- One day for Default
                      Just t  ->  round (utcTimeToPOSIXSeconds t) :: Word32
   --if (B.length btoken) /= 32
    --then fail "Invalid deviceToken"
   -- else
   if (LB.length bpayload > 256)
          then fail "Too long payload"
          else do
                putWord8 1
                putWord32be 10 --identifier
                putWord32be expiryTime
                putWord16be $ convert $ B.length btoken
                putByteString btoken
                putWord16be $ convert $ LB.length bpayload
                putLazyByteString bpayload
